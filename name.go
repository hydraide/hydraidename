// Package name helps distribute data evenly across servers.
// To use it, you need to specify:
// - the total number of servers to distribute the data across, e.g. 1000 servers,
// - how many levels deep the folder structure should be within a single server, e.g. 2 levels deep,
// - and the maximum number of folders per level.
//
// The `name` package helps determine on which server a particular data item (e.g. a swamp) should be stored,
// and also generates the appropriate folder path on that server based on the given parameters.
//
// For example, if we have a swamp represented by a namespace like Sanctuary/Realm/Swamp,
// the system will calculate:
// - which server should store that swamp,
// - and what the folder structure should look like on that server.
//
// Each swamp is stored in its own unique folder.
//
// Example folder paths generated by the system:
// - 600/ba22/703a
// - 774/e81a/9e24
//
// Folder names are guaranteed to be unique and are distributed evenly across all servers.
//
// Why do we specify the total number of servers?
// Typically, you don't start with 1000 physical servers, but if you configure the system with 1000 logical server slots,
// later on, when you need to scale, it's easy to split:
// - keep the first 500 server ranges on Server A,
// - and move the rest (501â€“1000) to a new Server B.
//
// This approach creates room on both servers and makes it easy to scale horizontally.
//
// Accessing data across the two servers:
// If you initially had only Server A, and later added Server B,
// you simply migrate the data belonging to logical servers 500â€“1000 over to Server B.
// Then, in your application, you create a second client instance pointing to Server B.
// When generating a swamp name using the `name` package,
// you also get the server number via the `GetServerNumber` function.
// Based on the returned server number, you decide which client instance to use:
// - if it's below 500, use the A client,
// - if it's 500 or above, use the B client.
//
// Itâ€™s that simple â€“ no need for an external orchestrator server.
// Everything is managed directly in the code.
package name

import (
	"fmt"
	"github.com/cespare/xxhash/v2"
	"path/filepath"
	"strings"
	"sync"
)

type Name interface {
	Sanctuary(sanctuaryID string) Name
	Realm(realmName string) Name
	Swamp(swampName string) Name
	Get() string
	GetFolderNumber(allFolders uint16) uint16
	IsWildcardPattern() bool
	ComparePattern(comparableName Name) bool
	GetSanctuaryID() string
	GetRealmName() string
	GetSwampName() string
	GetFullHashPath(rootPath string, islandID uint64, depth int, maxFoldersPerLevel int) string
}

type name struct {
	Path           string
	SanctuaryID    string
	RealmName      string
	SwampName      string
	HashPath       string
	ServerNumber   uint16
	FolderNumber   uint16
	hashPathMu     sync.Mutex
	folderNumberMu sync.Mutex
}

// New creates a new empty Name instance.
// Use this as the starting point for building hierarchical names
// by chaining Sanctuary(), Realm(), and Swamp().
func New() Name {
	return &name{}
}

// Sanctuary sets the top-level domain of the Name.
// Typically used to group major logical areas (e.g. "users", "products").
func (n *name) Sanctuary(sanctuaryID string) Name {
	return &name{
		SanctuaryID: sanctuaryID,
		Path:        sanctuaryID,
	}
}

// Realm sets the second-level scope under the Sanctuary.
// Often used to further categorize Swamps (e.g. "profiles", "settings").
func (n *name) Realm(realmName string) Name {
	return &name{
		SanctuaryID: n.SanctuaryID,
		RealmName:   realmName,
		Path:        n.Path + "/" + realmName,
	}
}

// Swamp sets the final segment of the Name â€” the Swamp itself.
// This represents the concrete storage unit where Treasures are kept.
// The full path becomes: sanctuary/realm/swamp.
func (n *name) Swamp(swampName string) Name {
	return &name{
		SanctuaryID: n.SanctuaryID,
		RealmName:   n.RealmName,
		SwampName:   swampName,
		Path:        n.Path + "/" + swampName,
	}
}

// Get returns the full hierarchical path of the Name in the format:
//
//	"sanctuary/realm/swamp"
//
// ðŸ”’ Internal use only: This method is intended for SDK-level logic,
// such as logging, folder path generation, or internal diagnostics.
// SDK users should never need to call this directly.
func (n *name) Get() string {
	return n.Path
}

// GetFolderNumber returns the 1-based index of the server responsible for this Name.
// It uses a fast, consistent xxhash hash over the combined Sanctuary, Realm, and Swamp
// to deterministically assign the Name to one of `allFolders` available slots.
//
// ðŸ”’ Internal use only: This function is used by the SDK to route
// the Name to the correct Hydra client instance in a distributed setup.
// It should not be called directly by application developers.
//
// Example (inside SDK logic):
//
//	client := router.Route(name.GetFolderNumber(1000))
func (n *name) GetFolderNumber(allFolders uint16) uint16 {

	n.folderNumberMu.Lock()
	defer n.folderNumberMu.Unlock()

	if n.FolderNumber != 0 {
		return n.FolderNumber
	}

	hash := xxhash.Sum64([]byte(n.SanctuaryID + n.RealmName + n.SwampName))

	n.FolderNumber = uint16(hash%uint64(allFolders)) + 1

	return n.FolderNumber

}

// IsWildcardPattern returns true if any part of the Name is set to "*".
func (n *name) IsWildcardPattern() bool {
	return n.SanctuaryID == "*" || n.RealmName == "*" || n.SwampName == "*"
}

// ComparePattern compares the last element of the path with the given SwampName
func (n *name) ComparePattern(comparableName Name) bool {
	if n.SanctuaryID != comparableName.GetSanctuaryID() {
		return false
	}
	if comparableName.GetRealmName() != "*" && n.RealmName != comparableName.GetRealmName() {
		return false
	}
	if comparableName.GetSwampName() != "*" && n.SwampName != comparableName.GetSwampName() {
		return false
	}
	return true
}

func (n *name) GetSanctuaryID() string {
	return n.SanctuaryID
}

func (n *name) GetRealmName() string {
	return n.RealmName
}

func (n *name) GetSwampName() string {
	return n.SwampName
}

func (n *name) GetFullHashPath(rootPath string, islandID uint64, depth int, maxFoldersPerLevel int) string {

	n.hashPathMu.Lock()
	defer n.hashPathMu.Unlock()

	if n.HashPath != "" {
		return n.HashPath
	}

	hashedDirectoryPath := generateHashedDirectoryPath(n.Path, depth, maxFoldersPerLevel)
	n.HashPath = filepath.Join(
		rootPath,
		fmt.Sprintf("%d", islandID),
		hashedDirectoryPath,
		generateSwampFolderName(n.Path))

	return n.HashPath

}

// Load reconstructs a Name from a given path string in the format:
//
//	"sanctuary/realm/swamp"
//
// It parses the path segments and returns a Name instance with all fields set.
//
// ðŸ”’ Internal use only: This function is intended for SDK-level logic,
// such as reconstructing a Name from persisted references, file paths, or routing metadata.
// It should not be called by application developers directly.
func Load(path string) Name {

	// We process the path and generate a Name object from it
	// The values sanctuaryID, realmName, and swampName are extracted from the path
	// To do this, we split the path by the '/' character
	// sanctuaryID is the first element
	// realmName is the second element
	// swampName is the last element
	splitPath := strings.Split(path, "/")
	sanctuaryID := splitPath[0]
	realmName := splitPath[1]
	swampName := splitPath[2]

	return &name{
		Path:        sanctuaryID + "/" + realmName + "/" + swampName,
		SanctuaryID: sanctuaryID,
		RealmName:   realmName,
		SwampName:   swampName,
	}

}

func generateHashedDirectoryPath(input string, depth int, maxFoldersPerLevel int) string {

	hash := xxhash.Sum64String(input)
	hashHex := fmt.Sprintf("%x", hash)

	charsPerLevel := len(fmt.Sprintf("%x", maxFoldersPerLevel-1))
	if charsPerLevel < 2 {
		charsPerLevel = 2
	}

	parts := make([]string, depth)
	for i := 0; i < depth; i++ {
		start := i * charsPerLevel
		end := start + charsPerLevel
		if end > len(hashHex) {
			end = len(hashHex)
		}
		parts[i] = hashHex[start:end]
	}

	return strings.Join(parts, "/")
}

func generateSwampFolderName(swampName string) string {
	sum := xxhash.Sum64([]byte(swampName))
	return fmt.Sprintf("%x", sum)
}
